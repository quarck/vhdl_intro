# An approximate equivalent to the following C code:
# 
# uint16_t a, b, d, c;
# a = 1; b = 1; d = 0;
# for (;;) {
#    	d = a + b;
# 		out (d);
# 		a = b; b = d;
# 		c = 0xffff;
# 		while ((c & 0xff00) != 0) { --c; }
# }
#

.data 
0x80:	a0: byte  
0x81:	a1: byte 
0x82:	b0: byte 
0x83:	b1: byte 
0x84:	d0: byte 
0x85:	d1: byte  
0x86:	c0: byte 
0x87:	c1: byte 
	
.code 
0x00:	ld.c 1
0x02:	st	a0 [0x80]
0x04:	st 	b0 [0x82]
0x06:	ld.c 0 
0x08:	st 	a1 [0x81]
0x0a:	st 	b1 [0x83]
0x0c:	st 	d0 [0x84]
0x0e:	st	d1 [0x85]

loop: 
0x10:	ld	a0 [0x80]
0x12:	add	b0 [0x82]
0x14:	st	d0 [0x84]
0x16:	out	0
0x18:	ld	a1 [0x81]
0x1a:	adc b1 [0x83]
0x1c:	st	d1 [0x85]
0x1e:	out 1
0x20:	ld 	b0 [0x82]
0x22:	st 	a0 [0x80]
0x24:	ld	b1 [0x83]
0x26:	st 	a1 [0x81]
0x28:	ld 	d0 [0x84]
0x2a:	st	b0 [0x82]
0x2c:	ld	d1 [0x85]
0x2e:	st	b1 [0x83] 
	
sleep:
0x30:	ld.c 255
0x32:	st	c0 [0x86]
0x34:	st	c1 [0x87]

sleep_loop:
0x36:	ld.c 1
0x38:	sub	c0 [0x86]
0x3a:	st	c0 [0x86]
0x40:	ld.c 0
0x42:	subc c1 [0x87]
0x44:	st	c1 [0x87]
0x46:	jnz sleep_loop [0x36]

0x48:	jmp loop [0x10]
